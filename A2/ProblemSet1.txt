Write the following Scheme functions:

A.  "veryLucky" - takes an integer and determines if it is "veryLucky".
    For purposes of this problem, a number is "veryLucky" if every if
    every one of its digits is either a 6 or an 8.  The function returns
    either true (#t) or false (#f).  For example, (veryLucky 6128) would
    return #f (false), because it has some digits that aren't 6 or 8.
    On the other hand, (veryLucky 866) would return #t (true).
    Your function should work for both positive and negative integers.
    You can assume that the parameter being passed in is an integer.
    You can use the modulo function, and you can use an integer division
    function, which you'd have to find in Dr. Racket's help facility.

B.  "firstMidLast" - takes a list, and returns a list with three elements:
    which are the first, middle, and last elements of the original inputted
    list.  For example, (firstMidLast '(10 11 12 13 14 15 16) should return
    the list (10 13 16).  You can assume that the incoming list has at
    least three elements, and is of odd length.  You will probably find it
    useful to break the problem down and create some helper functions.

C.  "shuffleListHalves" - takes a list, breaks it in half, and builds a
    new list that alternates the elements of the two list halves.
    For example, (shuffleListHalves '(1 2 3 4 55 66 77 88) would return
    the list (1 55 2 66 3 77 4 88).  This was obtained by splitting the
    original list into the two lists (1 2 3 4) and (55 66 77 88), and
    then merging them together.  Your function should also work on
    odd-length lists, in which case it would split the list into two
    halves with the leftmost list being the longer of the two.
    For example, (shuffleListHalves '(1 2 3 4 55 66 77 88 99)
    would return the list (1 66 2 77 3 88 4 99 55).  You will almost
    certainly find it useful to break the problem down and create
    some helper functions.

D.  "firstFunctionSmaller" - takes two functions F and G, and a list L.
    It returns a list containing those elements from L where F(L) < G(L).
    For example, (firstFunctionBigger double square '(1 2 -3 7))
    would return the list (-3 7), because those are the elements x of
    the original list for which double(x) < square(x). Of course, your
    function should work for any reasonable functions F and G, and any
    reasonable list L.

E.  "getNestedBiggest" - takes a list of integers, possibly nested, and returns
    the largest integer. For example, (getNestedBiggest '(2 3 (4 (7 6) 5)))
    should return 7.  You will find it useful to use the "list?" function,
    which works as follows:  (list? L) returns true if L is a list.

F.  A function "makePicker", that takes as input an integer N.
    It then builds and returns an "Picker" function based on N.

    The "picker" function that is produced (by your function makePicker)
    would have the property that it takes as input a list, and returns
    the Nth item from that list.

    For example, if makePicker was called as follows:

        (makePicker 5)

    a function would be produced that takes as input a list and returns
    the 5th element from that list.

    For example, if the original call had been made as follows:

       (define P (makePicker 5))

    then the the produced function P would behave as follows:

       (P '(4 8 2 9 -1 13))     *** would return -1
       (P '(-2 3 -4 8 9 1 7))   *** would return 9

    Your task is just to write makePicker.  You may find it useful to
    write one or more utility functions.  Of course, makePicker should
    work for ANY input integer, not just the one shown above.
